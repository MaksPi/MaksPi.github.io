<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial=scale=1.0">

  <title>Сборка мусора</title>
  
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/fonts.css">
  <link rel="shortcut icon" href="../img/iconfinder_graduation_cap.png">
</head>

<body>
  <div class="page-wrapper">
    <div class="page">
      <div class="main__header">
        <div class="main__header-group">
          <ol class="breadcrumbs">
            <li class="breadcrumbs__item breadcrumbs__item_home">
              <a class="breadcrumbs__link" title="Оглавление" href="../index.html"></a>
            </li>
            <li class="breadcrumbs__item"></li>
          </ol>
          <div class="updated-at">
            <div class="updated-at__content">2-го августа 2020</div>
          </div>
        </div>
        <h1 class="page__title">Сборка мусора</h1>
      </div>
      <div itemprop="articleBody">
        <p>Управление памятью в JavaScript выполняется автоматически и незаметно. Мы создаём примитивы, объекты, функции… Всё это занимает память.</p>
        <p>Но что происходит, когда что-то больше не нужно? Как JavaScript понимает, что пора очищать память?</p>
        <h2>Достижимость</h2>
        <p>Основной концепцией управления памятью в JavaScript является принцип <em>достижимости</em>.</p>
        <p>Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.</p>
        <ol>
          <li>
            <p>Существует базовое множество достижимых значений, которые не могут быть удалены.</p>
            <p>Например:</p>
            <ul>
              <li>Локальные переменные и параметры текущей функции.</li>
              <li>Переменные и параметры других функций в текущей цепочке вложенных вызовов.</li>
              <li>Глобальные переменные.</li>
              <li>(некоторые другие внутренние значения)</li>
            </ul>
            <p>Эти значения мы будем называть <em>корнями</em>.</p>
          </li>
          <li>
            <p>Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.</p>
            <p>Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. Далее вы познакомитесь с подробными примерами на эту тему.</p>
          </li>
        </ol>
        <p>В интерпретаторе JavaScript есть фоновый процесс, который называется <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0">сборщик мусора</a>. Он следит за всеми объектами и удаляет те, которые стали недостижимы.</p>
        <h2>Простой пример</h2>
        <p>Вот самый простой пример:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
<code class="token comment">// в user находится ссылка на объект</code>
<code class="token keyword">let</code> user <code class="token operator">=</code> <code class="token punctuation">{</code>
  name<code class="token punctuation">:</code> <code class="token string">"John"</code>
<code class="token punctuation">}</code><code class="token punctuation">;</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(4);</script>
              </span>
            </div>
          </div>
        </div>
        <div class="image" style="width: 144px">
          <iframe style="width: 144px; height: calc(150px + 4px)" src="../object-basics/garbage-collection/memory-user-john.html"></iframe>
          <div class="image__ratio" style="padding-top: 106.9444444444%"></div>
        </div>
        <p>Здесь стрелка обозначает ссылку на объект. Глобальная переменная <code>user</code> ссылается на объект <code>{name: "John"}</code> (мы будем называть его просто «John»). В свойстве <code>"name"</code> объекта John хранится примитив, поэтому оно нарисовано внутри объекта.</p>
        <p>Если перезаписать значение <code>user</code>, то ссылка потеряется:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
user <code class="token operator">=</code> <code class="token keyword">null</code><code class="token punctuation">;</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(1);</script>
              </span>
            </div>
          </div>
        </div>
        <div class="image" style="width: 225px">
          <iframe style="width: 225px; height: calc(159px + 4px)" src="../object-basics/garbage-collection/memory-user-john-lost.html"></iframe>
          <div class="image__ratio" style="padding-top: 72.44444444444%"></div>
        </div>
        <p>Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. Сборщик мусора удалит эти данные и освободит память.</p>
        <h2>Две ссылки</h2>
        <p>Представим, что мы скопировали ссылку из <code>user</code> в <code>admin</code>:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
<code class="token comment">// в user находится ссылка на объект</code>
<code class="token keyword">let</code> user <code class="token operator">=</code> <code class="token punctuation">{</code>
  name<code class="token punctuation">:</code> <code class="token string">"John"</code>
<code class="token punctuation">}</code><code class="token punctuation">;</code>

<code class="token keyword">let</code> admin <code class="token operator">=</code> user<code class="token punctuation">;</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(6);</script>
              </span>
            </div>
          </div>
        </div>
        <div class="image" style="width: 144px">
          <iframe style="width: 144px; height: calc(159px + 4px)" src="../object-basics/garbage-collection/memory-user-john-admin.html"></iframe>
          <div class="image__ratio" style="padding-top: 113.1944444444%"></div>
        </div>
        <p>Теперь, если мы сделаем то же самое:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
user <code class="token operator">=</code> <code class="token keyword">null</code><code class="token punctuation">;</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(1);</script>
              </span>

            </div>
          </div>
        </div>
        <p>…то объект John всё ещё достижим через глобальную переменную <code>admin</code>, поэтому он находится в памяти. Если бы мы также перезаписали <code>admin</code>, то John был бы удалён.</p>
        <h2>Взаимосвязанные объекты</h2>
        <p>Теперь более сложный пример. Семья:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
<code class="token keyword">function</code> <code class="token function">marry</code><code class="token punctuation">(</code><code class="token parameter">man<code class="token punctuation">,</code> woman</code><code class="token punctuation">)</code> <code class="token punctuation">{</code>
  woman<code class="token punctuation">.</code>husband <code class="token operator">=</code> man<code class="token punctuation">;</code>
  man<code class="token punctuation">.</code>wife <code class="token operator">=</code> woman<code class="token punctuation">;</code>

  <code class="token keyword">return</code> <code class="token punctuation">{</code>
    father<code class="token punctuation">:</code> man<code class="token punctuation">,</code>
    mother<code class="token punctuation">:</code> woman
  <code class="token punctuation">}</code>
<code class="token punctuation">}</code>

<code class="token keyword">let</code> family <code class="token operator">=</code> <code class="token function">marry</code><code class="token punctuation">(</code><code class="token punctuation">{</code>
  name<code class="token punctuation">:</code> <code class="token string">"John"</code>
<code class="token punctuation">}</code><code class="token punctuation">,</code> <code class="token punctuation">{</code>
  name<code class="token punctuation">:</code> <code class="token string">"Ann"</code>
<code class="token punctuation">}</code><code class="token punctuation">)</code><code class="token punctuation">;</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(15);</script>
              </span>
            </div>
          </div>
        </div>
        <p>Функция <code>marry</code> «женит» два объекта, давая им ссылки друг на друга, и возвращает новый объект, содержащий ссылки на два предыдущих.</p>
        <p>В результате получаем такую структуру памяти:</p>
        <div class="image" style="width: 337px">
          <iframe style="width: 337px; height: calc(204px + 4px)" src="../object-basics/garbage-collection/family.html"></iframe>
          <div class="image__ratio" style="padding-top: 61.72106824926%"></div>
        </div>
        <p>На данный момент все объекты достижимы.</p>
        <p>Теперь удалим две ссылки:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
<code class="token keyword">delete</code> family<code class="token punctuation">.</code>father<code class="token punctuation">;</code>
<code class="token keyword">delete</code> family<code class="token punctuation">.</code>mother<code class="token punctuation">.</code>husband<code class="token punctuation">;</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(2);</script>
              </span>
            </div>
          </div>
        </div>
        <div class="image" style="width: 337px">
          <iframe style="width: 337px; height: calc(204px + 4px)" src="../object-basics/garbage-collection/family-delete-refs.html"></iframe>
          <div class="image__ratio" style="padding-top: 61.72106824926%"></div>
        </div>
        <p>Недостаточно удалить только одну из этих ссылок, потому что все объекты останутся достижимыми.</p>
        <p>Но если мы удалим обе, то увидим, что у объекта John больше нет входящих ссылок:</p>
        <div class="image" style="width: 399px">
          <iframe style="width: 399px; height: calc(225px + 4px)" src="../object-basics/garbage-collection/family-no-father.html"></iframe>
          <div class="image__ratio" style="padding-top: 57.39348370927%"></div>
        </div>
        <p>Исходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект достижимым. Объект John теперь недостижим и будет удалён из памяти со всеми своими данными, которые также стали недоступны.</p>
        <p>После сборки мусора:</p>
        <div class="image" style="width: 144px">
          <iframe style="width: 144px; height: calc(225px + 4px)" src="../object-basics/garbage-collection/family-no-father-2.html"></iframe>
          <div class="image__ratio" style="padding-top: 159.0277777778%"></div>
        </div>
        <h2>Недостижимый «остров»</h2>
        <p>Вполне возможна ситуация, при которой целый «остров» связанных объектов может стать недостижимым и удалиться из памяти.</p>
        <p>Возьмём объект <code>family</code> из примера выше. А затем:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
family <code class="token operator">=</code> <code class="token keyword">null</code><code class="token punctuation">;</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(1);</script>
              </span>
            </div>
          </div>
        </div>
        <p>Структура в памяти теперь станет такой:</p>
        <div class="image" style="width: 420px">
          <iframe style="width: 420px; height: calc(279px + 4px)" src="../object-basics/garbage-collection/family-no-family.html"></iframe>
          <div class="image__ratio" style="padding-top: 67.38095238095%"></div>
        </div>
        <p>Этот пример демонстрирует, насколько важна концепция достижимости.</p>
        <p>Объекты John и Ann всё ещё связаны, оба имеют входящие ссылки, но этого недостаточно.</p>
        <p>У объекта <code>family</code> больше нет ссылки от корня, поэтому весь «остров» становится недостижимым и будет удалён.</p>
        <h2>Внутренние алгоритмы</h2>
        <p>Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).</p>
        <p>Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:</p>
        <ul>
          <li>Сборщик мусора «помечает» (запоминает) все корневые объекты.</li>
          <li>Затем он идёт по их ссылкам и помечает все найденные объекты.</li>
          <li>Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.</li>
          <li>…И так далее, пока не будут посещены все ссылки (достижимые от корней).</li>
          <li>Все непомеченные объекты удаляются.</li>
        </ul>
        <p>Например, пусть наша структура объектов выглядит так:</p>
        <div class="image" style="width: 463px">
          <iframe style="width: 463px; height: calc(204px + 4px)" src="../object-basics/garbage-collection/garbage-collection-1.html"></iframe>
          <div class="image__ratio" style="padding-top: 44.92440604752%"></div>
        </div>
        <p>Явно виден «недостижимый остров» справа. Теперь посмотрим, как будет работать «алгоритм пометок» сборщика мусора.</p>
        <p>На первом шаге помечаются корни:</p>
        <div class="image" style="width: 463px">
          <iframe style="width: 463px; height: calc(204px + 4px)" src="../object-basics/garbage-collection/garbage-collection-2.html"></iframe>
          <div class="image__ratio" style="padding-top: 44.92440604752%"></div>
        </div>
        <p>Затем помечаются объекты по их ссылкам:</p>
        <div class="image" style="width: 463px">
          <iframe style="width: 463px; height: calc(204px + 4px)" src="../object-basics/garbage-collection/garbage-collection-3.html"></iframe>
          <div class="image__ratio" style="padding-top: 44.92440604752%"></div>
        </div>
        <p>…а затем объекты по их ссылкам и так далее, пока это вообще возможно:</p>
        <div class="image" style="width: 463px">
          <iframe style="width: 463px; height: calc(204px + 4px)" src="../object-basics/garbage-collection/garbage-collection-4.html"></iframe>
          <div class="image__ratio" style="padding-top: 44.92440604752%"></div>
        </div>
        <p>Теперь объекты, до которых не удалось дойти от корней, считаются недостижимыми и будут удалены:</p>
        <div class="image" style="width: 463px">
          <iframe style="width: 463px; height: calc(204px + 4px)" src="../object-basics/garbage-collection/garbage-collection-5.html"></iframe>
          <div class="image__ratio" style="padding-top: 44.92440604752%"></div>
        </div>
        <p>Это и есть принцип работы сборки мусора.</p>
        <p>Интерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.</p>
        <p>Вот некоторые из оптимизаций:</p>
        <ul>
          <li><strong>Сборка по поколениям (Generational collection)</strong> – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.</li>
          <li><strong>Инкрементальная сборка (Incremental collection)</strong> – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.</li>
          <li><strong>Сборка в свободное время (Idle-time collection)</strong> – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.</li>
        </ul>
        <p>Существуют и другие способы оптимизации и разновидности алгоритмов сборки мусора. Но как бы мне ни хотелось описать их здесь, я должен воздержаться от этого, потому что разные интерпретаторы JavaScript применяют разные приёмы и хитрости. И, что более важно, всё меняется по мере развития интерпретаторов, поэтому углубляться в эту тему заранее, без реальной необходимости, вероятно, не стоит. Если, конечно, это не вопрос чистого интереса, тогда для вас будут полезны некоторые ссылки ниже.</p>
      </div>
    </div>
  </div>
</body>

</html>