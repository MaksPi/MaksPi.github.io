<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial=scale=1.0">

  <title>Преобразование объектов в примитивы</title>
  
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/fonts.css">
  <link rel="shortcut icon" href="../img/iconfinder_graduation_cap.png">
</head>

<body>
  <div class="page-wrapper">
    <div class="page">
      <div class="main__header">
        <div class="main__header-group">
          <ol class="breadcrumbs">
            <li class="breadcrumbs__item breadcrumbs__item_home">
              <a class="breadcrumbs__link" title="Оглавление" href="../index.html"></a>
            </li>
            <li class="breadcrumbs__item"></li>
          </ol>
          <div class="updated-at">
            <div class="updated-at__content">4-го августа 2020</div>
          </div>
        </div>
        <h1 class="page__title">Преобразование объектов в примитивы</h1>
      </div>
      <div itemprop="articleBody">
        <p>Что произойдёт, если сложить два объекта <code>obj1 + obj2</code>, вычесть один из другого <code>obj1 - obj2</code> или вывести их на экран, воспользовавшись <code>alert(obj)</code>?</p>
        <p>В этом случае объекты сначала автоматически преобразуются в примитивы, а затем выполняется операция.</p>
        <p>В главе <a href="../first-steps/type-conversions.html">Преобразование типов</a> мы видели правила для численных, строковых и логических преобразований. Но обделили вниманием объекты. Теперь, поскольку мы уже знаем о методах объектов и символах, можно исправить это упущение.</p>
        <ol>
          <li>Все объекты в логическом контексте являются <code>true</code>. Существуют лишь их численные и строковые преобразования.</li>
          <li>Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции. Например, объекты <code>Date</code> (мы рассмотрим их в статье <a href="/date">Дата и время</a>) могут вычитаться, и результатом <code>date1 - date2</code> будет временной отрезок между двумя датами.</li>
          <li>Что касается строковых преобразований – они обычно происходят, когда мы выводим объект <code>alert(obj)</code>, а также в других случаях, когда объект используется как строка.</li>
        </ol>
        <h2>Преобразование к примитивам</h2>
        <p>Мы можем тонко настраивать строковые и численные преобразования, используя специальные методы объекта.</p>
        <p>Существуют три варианта преобразований («три хинта»), описанные в <a href="https://tc39.github.io/ecma262/#sec-toprimitive">спецификации</a>:</p>
        <dl>
          <dt><code>"string"</code></dt>
          <dd>
            <p>Для преобразования объекта к строке, когда операция ожидает получить строку, например <code>alert</code>:</p>
            <div class="code-example">
              <div class="codebox">
                <div class="line-numbers language-javascript">
                  <code class="language-javascript">
<pre>
<code class="token comment">// вывод</code>
<code class="token function">alert</code><code class="token punctuation">(</code>obj<code class="token punctuation">)</code><code class="token punctuation">;</code>

<code class="token comment">// используем объект в качестве имени свойства</code>
anotherObj<code class="token punctuation">[</code>obj<code class="token punctuation">]</code> <code class="token operator">=</code> <code class="token number">123</code><code class="token punctuation">;</code>
</pre>
                  </code>
                  <span class="line-numbers-rows">
                    <script src="../js/line-numbers-rows.js"></script>
                    <script>rowsNumbers(5);</script>
                  </span>
                </div>
              </div>
            </div>
          </dd>
          <dt><code>"number"</code></dt>
          <dd>
            <p>Для преобразования объекта к числу, в случае математических операций:</p>
            <div class="code-example">
              <div class="codebox">
                <div class="line-numbers language-javascript">
                  <code class="language-javascript">
<pre>
<code class="token comment">// явное преобразование</code>
<code class="token keyword">let</code> num <code class="token operator">=</code> <code class="token function">Number</code><code class="token punctuation">(</code>obj<code class="token punctuation">)</code><code class="token punctuation">;</code>

<code class="token comment">// математическое (исключая бинарный оператор "+")</code>
<code class="token keyword">let</code> n <code class="token operator">=</code> <code class="token operator">+</code>obj<code class="token punctuation">;</code> <code class="token comment">// унарный плюс</code>
<code class="token keyword">let</code> delta <code class="token operator">=</code> date1 <code class="token operator">-</code> date2<code class="token punctuation">;</code>

<code class="token comment">// сравнения больше/меньше</code>
<code class="token keyword">let</code> greater <code class="token operator">=</code> user1 <code class="token operator">&gt;</code> user2<code class="token punctuation">;</code>
</pre>
                  </code>
                  <span class="line-numbers-rows">
                    <script src="../js/line-numbers-rows.js"></script>
                    <script>rowsNumbers(9);</script>
                  </span>
                </div>
              </div>
            </div>
          </dd>
          <dt><code>"default"</code></dt>
          <dd>
            <p>Происходит редко, когда оператор «не уверен», какой тип ожидать.</p>
            <p>Например, бинарный плюс <code>+</code> может работать с обоими типами: строками (объединять их) и числами (складывать). Таким образом, и те, и другие будут вычисляться. Или когда происходит сравнение объектов с помощью нестрогого равенства <code>==</code> со строкой, числом или символом, и неясно, какое преобразование должно быть выполнено.</p>
            <div class="code-example">
              <div class="codebox">
                <div class="line-numbers language-javascript">
                  <code class="language-javascript">
<pre>
<code class="token comment">// бинарный плюс</code>
<code class="token keyword">let</code> total <code class="token operator">=</code> car1 <code class="token operator">+</code> car2<code class="token punctuation">;</code>

<code class="token comment">// obj == string/number/symbol</code>
<code class="token keyword">if</code> <code class="token punctuation">(</code>user <code class="token operator">==</code> <code class="token number">1</code><code class="token punctuation">)</code> <code class="token punctuation">{</code> <code class="token operator">...</code> <code class="token punctuation">}</code><code class="token punctuation">;</code>
</pre>
                  </code>
                  <span class="line-numbers-rows">
                    <script src="../js/line-numbers-rows.js"></script>
                    <script>rowsNumbers(5);</script>
                  </span>
                </div>
              </div>
            </div>
            <p>Оператор больше/меньше <code>&lt;&gt;</code> также может работать как со строками, так и с числами. Однако, по историческим причинам он использует хинт «number», а не «default».</p>
            <p>На практике все встроенные объекты, исключая <code>Date</code> (мы познакомимся с ним чуть позже), реализуют <code>"default"</code> преобразования тем же способом, что и <code>"number"</code>. И нам следует поступать также.</p>
          </dd>
        </dl>
        <p>Обратите внимание, что существуют лишь три варианта хинтов. Всё настолько просто. Не существует хинта со значением «boolean» (все объекты являются <code>true</code> в логическом контексте) или каких-либо ещё. И если мы считаем <code>"default"</code> и <code>"number"</code> одинаковыми, как большинство встроенных объектов, то остаются всего два варианта преобразований.</p>
        <p><strong>В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:</strong></p>
        <ol>
          <li>Вызывает <code>obj[Symbol.toPrimitive](hint)</code> – метод с символьным ключом <code>Symbol.toPrimitive</code> (системный символ), если такой метод существует, и передаёт ему хинт.</li>
          <li>Иначе, если хинт равен <code>"string"</code>
            <ul>
              <li>пытается вызвать <code>obj.toString()</code>, а если его нет, то <code>obj.valueOf()</code>, если он существует.</li>
            </ul>
          </li>
          <li>В случае, если хинт равен <code>"number"</code> или <code>"default"</code>
            <ul>
              <li>пытается вызвать <code>obj.valueOf()</code>, а если его нет, то <code>obj.toString()</code>, если он существует.</li>
            </ul>
          </li>
        </ol>
        <h2>Symbol.toPrimitive</h2>
        <p>Начнём с универсального подхода – символа <code>Symbol.toPrimitive</code>: метод с таким названием (если есть) используется для всех преобразований:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
obj<code class="token punctuation">[</code>Symbol<code class="token punctuation">.</code>toPrimitive<code class="token punctuation">]</code> <code class="token operator">=</code> <code class="token keyword">function</code><code class="token punctuation">(</code><code class="token parameter">hint</code><code class="token punctuation">)</code> <code class="token punctuation">{</code>
<code class="token comment">// должен вернуть примитивное значение</code>
<code class="token comment">// hint равно чему-то одному из: "string", "number" или "default"</code>
<code class="token punctuation">}</code><code class="token punctuation">;</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(4);</script>
              </span>
            </div>
          </div>
        </div>
        <p>Для примера используем его в реализации объекта <code>user</code>:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
<code class="token keyword">let</code> user <code class="token operator">=</code> <code class="token punctuation">{</code>
  name<code class="token punctuation">:</code> <code class="token string">"John"</code><code class="token punctuation">,</code>
  money<code class="token punctuation">:</code> <code class="token number">1000</code><code class="token punctuation">,</code>

  <code class="token punctuation">[</code>Symbol<code class="token punctuation">.</code>toPrimitive<code class="token punctuation">]</code><code class="token punctuation">(</code>hint<code class="token punctuation">)</code> <code class="token punctuation">{</code>
    <code class="token function">alert</code><code class="token punctuation">(</code><code class="token template-string"><code class="token string">`hint: </code><code class="token interpolation"><code class="token interpolation-punctuation punctuation">${</code>hint<code class="token interpolation-punctuation punctuation">}</code></code><code class="token string">`</code></code><code class="token punctuation">)</code><code class="token punctuation">;</code>
    <code class="token keyword">return</code> hint <code class="token operator">==</code> <code class="token string">"string"</code> <code class="token operator">?</code> <code class="token template-string"><code class="token string">`{name: "</code><code class="token interpolation"><code class="token interpolation-punctuation punctuation">${</code><code class="token keyword">this</code><code class="token punctuation">.</code>name<code class="token interpolation-punctuation punctuation">}</code></code><code class="token string">"}`</code></code> <code class="token punctuation">:</code> <code class="token keyword">this</code><code class="token punctuation">.</code>money<code class="token punctuation">;</code>
  <code class="token punctuation">}</code>
<code class="token punctuation">}</code><code class="token punctuation">;</code>

<code class="token comment">// демонстрация результатов преобразований:</code>
<code class="token function">alert</code><code class="token punctuation">(</code>user<code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// hint: string -&gt; {name: "John"}</code>
<code class="token function">alert</code><code class="token punctuation">(</code><code class="token operator">+</code>user<code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// hint: number -&gt; 1000</code>
<code class="token function">alert</code><code class="token punctuation">(</code>user <code class="token operator">+</code> <code class="token number">500</code><code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// hint: default -&gt; 1500</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(14);</script>
              </span>
            </div>
          </div>
        </div>
        <p>Как мы видим из кода, <code>user</code> преобразовывается либо в информативную читаемую строку, либо в денежный счёт в зависимости от значения хинта. Единственный метод <code>user[Symbol.toPrimitive]</code> смог обработать все случаи преобразований.</p>
        <h2>Методы toString/valueOf</h2>
        <p>Методы <code>toString</code> и <code>valueOf</code> берут своё начало с древних времён. Они не символы, так как в то время символов ещё не существовало, а просто обычные методы объектов со строковыми именами. Они предоставляют «устаревший» способ реализации преобразований объектов.</p>
        <p>Если нет метода <code>Symbol.toPrimitive</code>, движок JavaScript пытается найти эти методы и вызвать их следующим образом:</p>
        <ul>
          <li><code>toString -&gt; valueOf</code> для хинта со значением «string».</li>
          <li><code>valueOf -&gt; toString</code> – в ином случае.</li>
        </ul>
        <p>Для примера, используем их в реализации всё того же объекта <code>user</code>. Воспроизведём его поведение комбинацией методов <code>toString</code> и <code>valueOf</code>:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
<code class="token keyword">let</code> user <code class="token operator">=</code> <code class="token punctuation">{</code>
  name<code class="token punctuation">:</code> <code class="token string">"John"</code><code class="token punctuation">,</code>
  money<code class="token punctuation">:</code> <code class="token number">1000</code><code class="token punctuation">,</code>

  <code class="token comment">// для хинта равного "string"</code>
  <code class="token function">toString</code><code class="token punctuation">(</code><code class="token punctuation">)</code> <code class="token punctuation">{</code>
    <code class="token keyword">return</code> <code class="token template-string"><code class="token string">`{name: "</code><code class="token interpolation"><code class="token interpolation-punctuation punctuation">${</code><code class="token keyword">this</code><code class="token punctuation">.</code>name<code class="token interpolation-punctuation punctuation">}</code></code><code class="token string">"}`</code></code><code class="token punctuation">;</code>
  <code class="token punctuation">}</code><code class="token punctuation">,</code>

  <code class="token comment">// для хинта равного "number" или "default"</code>
  <code class="token function">valueOf</code><code class="token punctuation">(</code><code class="token punctuation">)</code> <code class="token punctuation">{</code>
    <code class="token keyword">return</code> <code class="token keyword">this</code><code class="token punctuation">.</code>money<code class="token punctuation">;</code>
  <code class="token punctuation">}</code>

<code class="token punctuation">}</code><code class="token punctuation">;</code>

<code class="token function">alert</code><code class="token punctuation">(</code>user<code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// toString -&gt; {name: "John"}</code>
<code class="token function">alert</code><code class="token punctuation">(</code><code class="token operator">+</code>user<code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// valueOf -&gt; 1000</code>
<code class="token function">alert</code><code class="token punctuation">(</code>user <code class="token operator">+</code> <code class="token number">500</code><code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// valueOf -&gt; 1500</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(19);</script>
              </span>
            </div>
          </div>
        </div>
        <p>Как видим, получилось то же поведение, что и в предыдущем примере с <code>Symbol.toPrimitive</code>.</p>
        <p>Довольно часто мы хотим описать одно «универсальное» преобразование объекта к примитиву для всех ситуаций. Для этого достаточно создать один <code>toString</code>:</p>
        <div class="code-example">
          <div class="codebox">
            <div class="line-numbers language-javascript">
              <code class="language-javascript">
<pre>
<code class="token keyword">let</code> user <code class="token operator">=</code> <code class="token punctuation">{</code>
  name<code class="token punctuation">:</code> <code class="token string">"John"</code><code class="token punctuation">,</code>

  <code class="token function">toString</code><code class="token punctuation">(</code><code class="token punctuation">)</code> <code class="token punctuation">{</code>
    <code class="token keyword">return</code> <code class="token keyword">this</code><code class="token punctuation">.</code>name<code class="token punctuation">;</code>
  <code class="token punctuation">}</code>
<code class="token punctuation">}</code><code class="token punctuation">;</code>

<code class="token function">alert</code><code class="token punctuation">(</code>user<code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// toString -&gt; John</code>
<code class="token function">alert</code><code class="token punctuation">(</code>user <code class="token operator">+</code> <code class="token number">500</code><code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// toString -&gt; John500</code>
</pre>
              </code>
              <span class="line-numbers-rows">
                <script src="../js/line-numbers-rows.js"></script>
                <script>rowsNumbers(10);</script>
              </span>
            </div>
          </div>
        </div>
        <p>В отсутствие <code>Symbol.toPrimitive</code> и <code>valueOf</code>, <code>toString</code> обработает все случаи преобразований к примитивам.</p>
        <h2>Возвращаемые типы</h2>
        <p>Важно понимать, что все описанные методы для преобразований объектов не обязаны возвращать именно требуемый «хинтом» тип примитива.</p>
        <p>Нет обязательного требования, чтобы <code>toString()</code> возвращал именно строку, или чтобы метод <code>Symbol.toPrimitive</code> возвращал именно число для хинта «number».</p>
        <p><strong>Единственное обязательное требование: методы должны возвращать примитив, а не объект.</strong></p>
        <div class="important important_smart">
          <div class="important__header"><span class="important__type">Историческая справка</span></div>
          <div class="important__content"><p>По историческим причинам, если <code>toString</code> или <code>valueOf</code> вернёт объект, то ошибки не будет, но такое значение будет проигнорировано (как если бы метода вообще не существовало).</p>
            <p>Метод <code>Symbol.toPrimitive</code>, напротив, <em>обязан</em> возвращать примитив, иначе будет ошибка.</p>
          </div>
        </div>
        <h2>Последующие операции</h2>
        <p>Операция, инициировавшая преобразование, получает примитив и затем продолжает работу с ним, производя дальнейшие преобразования, если это необходимо.</p>
        <p>Например:</p>
        <ul>
          <li>
            <p>Математические операции, исключая бинарный плюс, преобразуют примитив к числу:</p>
            <div class="code-example">
              <div class="codebox">
                <div class="line-numbers language-javascript">
                  <code class="language-javascript">
<pre>
<code class="token keyword">let</code> obj <code class="token operator">=</code> <code class="token punctuation">{</code>
  <code class="token comment">// toString обрабатывает все преобразования в случае отсутствия других методов</code>
  <code class="token function">toString</code><code class="token punctuation">(</code><code class="token punctuation">)</code> <code class="token punctuation">{</code>
    <code class="token keyword">return</code> <code class="token string">"2"</code><code class="token punctuation">;</code>
  <code class="token punctuation">}</code>
<code class="token punctuation">}</code><code class="token punctuation">;</code>

<code class="token function">alert</code><code class="token punctuation">(</code>obj <code class="token operator">*</code> <code class="token number">2</code><code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// 4, объект был преобразован к примитиву "2", затем умножение сделало его числом</code>
</pre>
                  </code>
                  <span class="line-numbers-rows">
                    <script src="../js/line-numbers-rows.js"></script>
                    <script>rowsNumbers(8);</script>
                  </span>
                </div>
              </div>
            </div>
          </li>
          <li>
            <p>Бинарный плюс <code>+</code> в аналогичном случае сложит строки:</p>
            <div class="code-example">
              <div class="codebox">
                <div class="line-numbers language-javascript">
                  <code class="language-javascript">
<pre>
<code class="token keyword">let</code> obj <code class="token operator">=</code> <code class="token punctuation">{</code>
  <code class="token function">toString</code><code class="token punctuation">(</code><code class="token punctuation">)</code> <code class="token punctuation">{</code>
    <code class="token keyword">return</code> <code class="token string">"2"</code><code class="token punctuation">;</code>
  <code class="token punctuation">}</code>
<code class="token punctuation">}</code><code class="token punctuation">;</code>

<code class="token function">alert</code><code class="token punctuation">(</code>obj <code class="token operator">+</code> <code class="token number">2</code><code class="token punctuation">)</code><code class="token punctuation">;</code> <code class="token comment">// 22 (преобразование к примитиву вернуло строку =&gt; конкатенация)</code>
</pre>
                  </code>
                  <span class="line-numbers-rows">
                    <script src="../js/line-numbers-rows.js"></script>
                    <script>rowsNumbers(7);</script>
                  </span>
                </div>
              </div>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
</body>

</html>